# Humam Rashid
# CISC 7510X, Fall 2019.

Inventory System for Automobile Junkyard
----------------------------------------

In attempting to design the inventory system, I wasn't sure if the requirements
were limited to search data only (i.e., data on the available parts only) or the
entire process of searching, buying, etc. To be safe, I assumed that more or
less the entire process is required based on my understanding of how typical
inventory systems (e.g., online bookstores) work. Due to this, my design is an
amalgamation of the online store DB design discussed in class along with
management requirements for junkyard automobile parts. The schema are divided
into sections for ease of reading but its meant to be all in one database.

The following is the schema for the transactions section of section inventory
system and is based directly on the design discussed in class, adjusted for the
junkyard-specific use case:

Transactions
------------
create table customer(
    customerid bigint       not null,
    name       varchar(100) not null,
    address    varchar(100) not null,
    phone1     varchar(20)  not null,
    phone2     varchar(20),
    email      varchar(100)
);
create table purchase(
    purchaseid bigint    not null,
    customerid bigint    not null,
    ptime      timestamp not null
);
create table purchase_detail(
    purchaseid bigint not null,
    partid,    bigint not null,
    quantity   bigint not null
);
create table price_history(
    partid bigint       not null,
    price  numeric(8,2) not null,
    prtime timestamp    not null
);

The purposes of the above tables were discussed at length in class so I am not
repeating them here. The table 'products' is left out above in contrast to the
class notes and instead replaced with 'parts' since products in the junkyard are
of a specific variety. It is mentioned separately with the search & inventory
management section of the system. 

The following is the schema for the inventory tracking and search facilities of
a junkyard business:

Search & Inventory Management
-----------------------------
create table automobile(
    autoid bigint       not null,
    color  varchar(100) not null,
    make   varchar(100) not null,
    model  varchar(100) not null,
    body   varchar(100) not null,
    year   integer      not null
);

The 'automobile' table catalogs specific car types that have ever been brought
into the junkyard or expected to be (see 'waiting_list' below). An entry is
added to this table as soon as a new car or part is brought in or a customer
indicates that he/she is interested in parts for the specific car type. A
typical insert may look like `insert into automobile values(000001, "Black",
"Honda", "Accord", "Sedan", 2019)`. Since all junkyards using this software are
linked through it, any specific junkyard is expected to have many car types
cataloged in 'automobile' table for which no parts may exist in a specific shop.

create table parts(
     autoid    bigint       not null,
     partid    bigint       not null,
     modid     bigint,
     partdesc  varchar(500) not null,
     partprice numeric(8,2) not null,
     quantity  bigint       not null
     localeid  bigint
);

The 'parts' table catalogs specific parts relative to a specific car type that
have ever been brought into the junkyard or expected to be. An entry is added to
this table as soon as a new part is available (e.g., when a new car is brought
in and scrapped) or when a customer indicates that he/she is interested in a
specific part ('quatity' would still be zero in this case). The 'modid' field
indicates if it is a modified part or not (could be null). 'partprice' is the
latest price (last value of 'price' from 'price_history' table). The 'quantity'
field of course indicates the number of such parts available. The 'partdesc'
field indicates name and type with any additional info. (e.g., engine, gas tank,
cracked left-side mirror, etc.). A typical insert may look like `insert into
parts values(000001, 000001, null, "brakes", 20.00, 2, 000018)`. A 'localeid' is
needed only when it becomes available in a particular junkyard.

create table compatible(
    partid bigint not null,
    autoid bigint not null,
    moded  boolean
);

The 'compatible' table catalogs which entries in the 'parts' table is compatible
with which entries in the 'automobile' table. It is expected that certain parts
from some car model for instance, could be compatible with other models as well.
So brakes from a Black Honda Accord could possibly be used with many other
sedans regardless of color or model. The 'moded' field indicates if a
modification is required to make it compatible (i.e., true = modification
required); it is possibly null because modification depends on what the specific
junkyard and its technicians are capable of and willing to do and may change
over time. The other fields cannot be null and at least one entry is required
for each part, so at least one entry is created for this table as soon as an
entry is added to the 'parts' table. A typical insert may look like `insert into
compatible values(000001, 000001, null)`. Another entry for part 000001 but with
a different 'autoid' indicates that this part is also compatible with this type
of car.

create table location(
    localeid bigint,
    partid   bigint,
    street   varchar(20),
    city     varchar(20),
    county   varchar(20),
    postal   varchar(10),
    country  varchar(20),
    phone    varchar(20),
    email    varchar(100),
    link     varchar(100)
);

The following is the schema of a limited set of services/processing work that
might be performed in a typical junkyard:

Services & Processing Management
--------------------------------
create table modification(
    modid    bigint,
    partid   bigint,
    original varchar(100),
    current  varchar(100)
);
create table mod_history(
    partid  bigint,
    moddesc varchar(500),
    mtime   timestamp
);
create table waiting_list(
    customerid bigint,
    partid     bigint,
    quantity   bigint
);
create table delivery(
    deilveryid bigint,
    purchaseid bigint,
    localeid   bigint,
    dtime      timestamp
);

# EOF.
